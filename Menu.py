
import sys, pygame, random
from pygame.locals import *#Color, KEYUP, K_ESCAPE, K_RETURN
import Objs2

class Menu: 

	def __init__(self):
		self.sqs = Squares()
		#self.sqs.add('exit')
		self.selected = "default"
		
	def addChoice(self,string): 
		self.sqs.add(string)

	
	''' finds which box was selected'''
	def selectedBox(self):
		#print "self.selected in selectedBox is: ", self.selected		
		return self.selected
					
	def resetSelectedBox(self):
		self.selected = 'Nothing22'

	'''creates a version of the menu in which nothing is selected'''				
	def makeBasicMenu(self):			
		tup = self.sqs.getTup()
		button = tup[0] #arbitrary choice of buttons 
		rect = button.getRect()
		self.surface = pygame.Surface((rect.width,rect.height * len(tup)))
		for sq in tup:
			#print sq.getName()
			#print sq.getTopLeft()
			self.surface.blit( sq.getNotClickedButton(),sq.getTopLeft() )
			
		
	def getBasicMenu(self):
		return self.surface
		
	'''uses menu generated by 'makeBasicMenu' to show which box the mouse is currently hovering over '''
	
	#coords are where you clicked
	#map holds (asides from other things) the value for where the mouse CURRENTLY is 
	def currentMenu(self,map,coords):
	
		tempCoords = [coords[0] +2,coords[1] +2]
		#print "3 ----"
		clicked = map['button'] #should be set to button3 aka the right click on the mouse
		tempTup = map['coords']
		
		#adjust the mouseLoc for being inside the surface obj
		mouseLoc = [tempTup[0] - coords[0],tempTup[1] - coords[1]]
		
		#tempSurface = pygame.Surface((self.surface.get_width(),self.surface.get_height()),0,self.surface)
		tempSurface = self.surface
		surfaceRect = tempSurface.get_rect()
		#if the surface object contains the point (don't bother doing a search otherwise)...
		if surfaceRect.collidepoint(mouseLoc) == True: 
			tup = self.sqs.getTup()			
			for button in tup:	
				
				#if a right click from the mouse was detected and the button
				# that we're currently looking at was the one that was clicked on...
				#print "clicked is: ", clicked
				#print "loc is: ", mouseLoc
				#print "button.getModRect() is: ",button.getModRect(mouseLoc)
				
				if (clicked == "down") and button.calcLoc(mouseLoc) :
					#print "6 ----"
					self.selected = button.getName()
					#print "the selected one was: ", self.selected
					tempSurface.blit(button.getClickedButton(),button.getTopLeft())
					#tempSurface.blit(button.getClickedButton(),button.getTopLeft(),button.getRect())
				
					sol = (tempSurface,tempCoords)	
					return sol
		#else:
		#otherwise, jusr return the blank menu
		#print "howdy"
		self.makeBasicMenu()
		sol = (self.surface,tempCoords)	
		return sol
			

	def clickedOn(self,map):
		#print "2 ----" 
		rect = self.surface.get_rect()
		if rect.collidepoint(map['coords']) == True and map['button3'] == True:
			return True
		else:
			return False
			
			
class Squares:

	def __init__(self):
		self.tup = [] #holds each Square
		self.count = 0 #used to calculate topLeft AKA so that we know where to put each button
		self.longestWidth = 1
		self.standardRect = pygame.Rect((1,1),(1,1))
		
	#note: the switcheroos for this method have to be this way since I have to keep exit's
	#surface location at the bottom of the menu surface object. It doesn't just need to be
	# at the end of the list itself. 
	def add(self,string):#formerly named addSquare
		#print " 8----"
		
		if self.count > 0:
			#print "9 ----"
			temp = Square(string)
			rect = temp.getRect()
			loc = (0, rect.height * self.count)
			tempSq = self.tup[self.count -1]
			temp.setTopLeft(tempSq.getTopLeft())
			tempSq.setTopLeft(loc)
			self.tup[self.count -1] = temp
			self.tup.append(tempSq)
			
			# for element in self.tup:
				# print element.getName(),"  "
			
			
		
		#add whatever, then add exit. 
		if self.count == 0:
			#print "10 ---"
		
			temp = Square(string)
			rect = temp.getRect()
			loc = (0, rect.height * self.count)
			
			#set incoming string as first object
			self.tup.append(temp)
			
			#increment count, set the next location to the exit obj, and put it into self.tup
			self.count += 1
			temp2 = Square('exit')
			rect = temp.getRect()
			loc = (0, rect.height * self.count)
			temp2.setTopLeft(loc)
			self.tup.append(temp2)
			
		self.count +=1
		#print "self.count is: ", self.count
		self.widestSquare(rect)
		
		
	def widestSquare(self,rect):
		if rect.width > self.longestWidth:
			for square in self.tup:
				square.updateBoxSize(rect)
			self.longestWidth = rect.width
			self.standardRect = rect
			
	def getTup(self):
		return self.tup
		
	#for completely replacing/resetting the tup 
	def setTup(self,list): 
		self.tup = list
		
	def getRect(self):
		return self.rect 

class Square:

	def __init__(self, name = "T"): #T for testing
		width = 10
		height = 10
		self.font = 'freesansbold.ttf'
		self.fontSize = 10 #can be adjusted to adjust size of font
		self.notClickedTextColor = Color("green")
		self.notClickedBoxColor = Color("black")
		
		self.clickedTextColor = Color("black")
		self.clickedBoxColor = Color("green")
		
		self.string = name
		
		self.spot = (0,0) #for topLeft
		self.rect = pygame.Rect((1,1),(1,1))#forgot what this is for. (biggest square?) 
		
		self.BASICFONT = pygame.font.Font(self.font,self.fontSize)
		
		print "self.notClickedTextColor is: ", self.notClickedTextColor
		textSurface_notClickedText = self.BASICFONT.render(self.string,True,self.notClickedTextColor, self.notClickedTextColor )
		textSurface_clickedText = self.BASICFONT.render(self.string, True, self.clickedTextColor,Color("black"))
		textRectangle = textSurface_clickedText.get_rect() #doesn't matter which textSurface obj you used...both are the same size
		
		self.rect = textRectangle 
		
		self.notClickedBox = pygame.Surface((textRectangle.width,textRectangle.height))
		self.notClickedBox.fill(Color("black"))
		self.notClickedBox.blit(textSurface_notClickedText,(0,0))
		
		self.clickedBox = pygame.Surface((textRectangle.width,textRectangle.height))
		self.clickedBox.fill(Color("green"))
		self.clickedBox.blit(textSurface_clickedText,textRectangle)
	
	def getClickedButton(self):
		return self.clickedBox
		
	def getNotClickedButton(self):
		return self.notClickedBox
		
	def updateBoxWord(self,string): #I have no idea why I made this method. (delete?) 
		self.string = string
		self.clickedBox.fill(Color("green"))
		self.notClickedBox.fill(Color("black"))
		
		textSurface_notClickedText = self.BASICFONT.render(self.string, True, self.notClickedTextColor,None)
		# textSurface_notClickedText = self.BASICFONT.render(self.string, True, self.notClickedTextColor,None)
		# textRectangle = textSurface_notClickedText.get_rect() # both boxes will be the same size, so no need to make this variable twice
		self.notClickedBox.blit(textSurface_notClickedText,textRectangle)
		
		textSurface_clickedText = BASICFONT.render(str(self.string), True, self.clickedTextColor,None)
		self.clickedBox.blit(textSurface_clickedText,textRectangle)
		
	def updateBoxSize(self,rect):
		width = rect.width
		height = rect.height
		self.rect = rect
		
		self.clickedBox = pygame.Surface((width,height))
		self.clickedBox.fill(Color("green"))
		
		self.notClickedBox = pygame.Surface((width,height))
		self.clickedBox.fill(Color("black"))
		
		textSurface_notClickedText = self.BASICFONT.render(self.string, True, self.notClickedTextColor,self.notClickedTextColor)
		textSurface_clickedText = self.BASICFONT.render(self.string, True, self.clickedTextColor,self.clickedTextColor)
		
		textRectangle = textSurface_notClickedText.get_rect() # both boxes will be the same size, so no need to make this variable twice
		
		self.notClickedBox.blit(textSurface_notClickedText,textRectangle)
		self.clickedBox.blit(textSurface_clickedText,textRectangle)
		#print "for ",self.string," clickedBox.get_width is: ",self.clickedBox.get_width()
	
	def setTopLeft(self,loc):
		self.spot = loc
		
	def getTopLeft(self):
		return self.spot
		
	def getHeight(self):
		return self.rect.height
		
	def getRect(self):
		return self.rect
		
	def getName(self):
		return self.string
		
	def setName(self,name):
		self.string = name
		
	def containsPoint(self,point): #I believe that I should delete this method
		self.rect.topleft = self.spot
		if self.rect.collidepoint(point):
			return True
		else:
			return False
	
	#calculate point
	def calcLoc(self,mouseTup):
	
		#print "5 ----" 
		
		tempRect = pygame.Rect(self.spot[0],self.spot[1],self.rect.width,self.rect.height)
		
		#print "mouse is at: ",mouseTup
		#print "square is at ",self.spot, " and is ", self.rect.width ," wide and ", self.rect.height ," long"
		#print " True if it contains the point, false if it doesn't: ", tempRect.collidepoint(mouseTup)
		
		tempMouseTup = [mouseTup[0] - 1, mouseTup[1] - 1]
		if tempRect.collidepoint(tempMouseTup):
			return True
		else:
			return False
			
	def getModRect(self,mouseTup):
		tempRect = pygame.Rect(self.spot[0],self.spot[1],self.rect.width,self.rect.height)
		return tempRect
	